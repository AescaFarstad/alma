Almaty OpenStreetMap Data Extract

## Overview

This dataset contains geographic information about Almaty, Kazakhstan, extracted and processed from OpenStreetMap (OSM). The data represents real-world features including buildings, roads, and other urban infrastructure.

-   **Original Source**: OpenStreetMap (OSM)
-   **License**: Open Database License (ODbL) 1.0
-   **Coverage Area**: Central Almaty, Kazakhstan

## Data Pipeline

The data flows through a multi-stage pipeline to transform raw OpenStreetMap data into vector tiles consumable by the web application. The GeoJSON files generated by `process_osm_data.js` are a critical intermediate step, serving as the direct input for the tile generation stage.

1.  **Raw OSM Data**: The process starts with a large `.pbf` file containing OSM data for a large region (e.g., `kazakhstan-latest.osm.pbf`).

2.  **Data Processing (`src/mapgen/process_osm_data.js`)**: This Node.js script is the core of the data preparation.
    *   **Extraction**: It clips the data to a smaller, predefined bounding box (e.g., `city_center`).
    *   **Feature Filtering**: It filters the data to keep only desired features (e.g., `w/building`, `w/highway`), as defined in the `FEATURES_TO_EXTRACT` object.
    *   **Property Cleaning**: It removes non-essential tags (e.g., `name:*`, `addr:*`) to reduce data size, as defined in the `REMOVE_TAGS` array.
    *   **GeoJSON Conversion**: The script's primary output is a set of cleaned `.geojson` files (e.g., `buildings.geojson`), which contain the geometry and final properties for each feature type.

3.  **Tile Generation (Planetiler)**: The `.geojson` files are then used as input for a tile generator like [Planetiler](https://github.com/onthegomap/planetiler). Planetiler converts this data into a highly efficient vector tile format, embedding the feature data (geometry and properties) into the tiles. The output is a single `almaty.mbtiles` database file.

4.  **Tile Extraction (mb-util)**: The `.mbtiles` database is unpacked into a directory of individual tile files (`/tiles/{z}/{x}/{y}.pbf`) using a tool like [mb-util](https://github.com/mapbox/mbutil). This folder structure is what the web server serves to the application.

5.  **Application Consumption**: The Vue application loads the tiles from the server. When you click on a feature like a building, the application queries the data already present in the vector tiles that have been downloaded to your browser.

---

## Updating the Data

When you need to change the map data, you must re-run parts or all of the data pipeline. All processing commands can be configured in `src/mapgen/process_osm_data.js` and executed via the corresponding `.vscode/tasks.json` tasks.

| If you decide to...                                | You need to...                                                                                                                                                                                                                                  |
| :------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Keep more properties** (e.g., building names)    | 1. **Edit `process_osm_data.js`**: Remove tags (e.g., `'name:*'`) from the `REMOVE_TAGS` array. <br/> 2. **Re-run the full pipeline**: `process_osm_data.js` → `planetiler` → `mb-util`.                                                     |
| **Enlarge the map area**                           | 1. **Edit `process_osm_data.js`**: Change the `AREA_TO_EXTRACT` variable to `'city_main'` or `'city_full'`. <br/> 2. **Re-run the full pipeline**.                                                                                           |
| **Add new features** (e.g., waterways, amenities)  | 1. **Edit `process_osm_data.js`**: Uncomment the desired lines in the `FEATURES_TO_EXTRACT` object. <br/> 2. **Re-run the full pipeline**.                                                                                                     |
| **Increase the maximum zoom level**                | The current tiles are generated up to zoom level 15. The map client "overzooms" by stretching these tiles up to level 18. This does not add more detail. To generate tiles with higher detail, you would need to modify the Planetiler settings to specify a higher max zoom, which would significantly increase processing time and storage. |

---

## Development & Caching

### Disabling Cache (Development)

During development, you want to see data changes immediately. Your browser's cache can prevent this.

-   **Browser DevTools**: The most effective method is to open your browser's Developer Tools, go to the "Network" tab, and check the "Disable cache" option.
-   **Vite Dev Server**: The Vite dev server has built-in mechanisms for hot module replacement (HMR) for code, but it may not automatically handle changes in the static `public` directory where the tiles are located. Restarting the tile-serving process and disabling browser cache is the most reliable approach.

### Enabling Cache (Production)

In a production environment, caching is crucial for performance. You don't need to do anything in the application code. Caching should be configured on the web server that serves the static tile files.

-   **Server Configuration**: Configure your web server (e.g., Nginx, Apache) to serve files from the `/tiles` directory with long-lived `Cache-Control` headers. This tells browsers to store the tiles locally for a long time, reducing server load and speeding up map navigation for repeat visitors.

Example Nginx configuration:
```nginx
location /tiles/ {
  root /path/to/your/project/public;
  expires 1y;
  add_header Cache-Control "public";
}
```

---

## Advanced: Handling Dynamic Data (e.g., Car Simulation)

When you need to display a large number of dynamic objects (like vehicles) that update frequently (e.g., every frame), the standard `source.setData()` approach can become a performance bottleneck. Here's a guide to handling this efficiently.

### The Challenge with `setData`

Calling `source.setData()` on a GeoJSON source is easy to implement but has performance limitations:
- **CPU Intensive**: It requires processing a potentially large GeoJSON object on the CPU every time it's called.
- **Data Transfer**: It involves transferring the entire dataset from the JavaScript main thread to the map's web worker and then to the GPU on each update.
- **Frame Rate Impact**: For many objects updating every frame, this process can easily overwhelm the main thread and cause your animation to stutter.

### The Performant Solution: Custom WebGL Layers

For high-performance rendering, the best practice is to bypass the GeoJSON source and render your objects directly with WebGL using a [Custom Layer](https://maplibre.org/maplibre-gl-js-docs/example/custom-layer/). This gives you direct access to the map's rendering context.

**How it Works:**

1.  **You Own the Rendering**: You provide the logic to draw your objects. This involves writing your own **vertex and fragment shaders** in GLSL (OpenGL Shading Language).
    *   The **vertex shader** calculates the screen position of each car.
    *   The **fragment shader** determines the color of each pixel for the car's sprite.
2.  **Direct GPU Data Management**: You create and manage your own WebGL buffers on the GPU to store car data (positions, rotations, colors, etc.).
3.  **Efficient Updates**: On each frame, instead of sending a large GeoJSON object, you only send the small amount of changed data (the new positions) directly to the GPU buffer. This is significantly faster.

**Steps to Implement:**

1.  **Create a Custom Layer Class**: Define a JavaScript class that implements MapLibre's `CustomLayerInterface`. This class will have methods like `onAdd` (to set up shaders and buffers) and `render` (which is called on every frame).
2.  **Write GLSL Shaders**: Create shader programs to draw your car sprites (e.g., textured quads).
3.  **Manage Data in Buffers**: In the `onAdd` method, create a WebGL buffer. In the `render` method, update this buffer with the latest car locations and then issue a draw call (`gl.drawArrays` or `gl.drawElements`).
4.  **Add to Map**: Instantiate your custom layer and add it to the map using `map.addLayer()`.

While this approach requires knowledge of WebGL, it is the standard technique for high-performance graphics and is the only way to ensure a smooth frame rate when simulating hundreds or thousands of moving objects on a map.

---

## Modifying Features vs. Adding New Ones

A common challenge is deciding how to handle dynamic data. There are three primary methods, each suited for a different task.

| Method                   | Use For...                                                                               | Example                                                                       | Performance           |
| :----------------------- | :--------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------- | :-------------------- |
| **`map.setFeatureState()`**  | Changing the **appearance of existing features** that are already in your vector tiles.  | Coloring buildings by team, highlighting districts, showing selected roads.   | **Excellent**         |
| **`source.setData()`**     | Adding a **small-to-medium number of new features** that are not in your base tiles.     | A user's planned route, a few drones updating every 5s, search results.       | **Good** (for its use case) |
| **Custom WebGL Layer**   | Adding a **large number of new features** that must update every frame.                    | Simulating hundreds of cars, weather particles, bullet projectiles.           | **Best** (for high-frequency) |

### Use Case: Coloring Captured Buildings (`setFeatureState`)

This is the most efficient way to change the properties of features that are already part of the map.

1.  **Style Modification**: Update your style layer to react to a "state". In `App.vue`, the `buildings` layer `paint` property can be changed to use a `case` expression that checks for a state property (e.g., `team`).

    ```javascript
    "fill-color": [
      "case",
      ["==", ["feature-state", "team"], "blue"], "#87ceeb", // If state 'team' is 'blue'
      ["==", ["feature-state", "team"], "red"], "#f08080",   // If state 'team' is 'red'
      "#cccccc" // Default color
    ]
    ```

2.  **Game Logic**: When a building is clicked or captured, use `map.setFeatureState()` to apply a state to it using its unique feature ID.

    ```javascript
    const featureId = clickedFeature.id;
    map.setFeatureState(
      { source: 'almaty-tiles', sourceLayer: 'building', id: featureId },
      { team: 'blue' }
    );
    ```
This approach is extremely fast as it does not require re-sending or duplicating any geometry data.