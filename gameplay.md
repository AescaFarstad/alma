# Alma Game Design Document

## 1. High-Level Overview

Alma is a real-time strategy and resource management game. The core gameplay revolves around acquiring and developing buildings on a real-world map, managing a workforce of units with different professions, and controlling territory through strategic assaults.

The game's logic is designed to be data-oriented, using Plain Old Data (POD) structures for game objects. The economic and statistical models are powered by a reactive `Stat` system (`src/logic/core/Stat.ts`), where changes to one value automatically propagate through a graph of interconnected stats. (Read more at `src/logic/core/HowToStats.md`)

## 2. Core Gameplay Loop

The player's progression follows a primary cycle of activities:

1.  **Acquire:** Players expand their influence by launching `Assaults` on neutral or enemy-controlled buildings. A successful assault grants control of the building to the player.
2.  **Develop:** Once controlled, a building can be customized by installing `BuildingModules` (e.g., Greenhouses, Labs, Factories) into its available `BuildingSlots`. This specialization costs resources.
3.  **Assign:** A `BuildingModule` is inactive until a `Unit` is assigned to occupy it. The assigned unit adopts the profession associated with the module (e.g., a unit in a Greenhouse becomes a `Farmer`).
4.  **Manage:** Players must balance a continuous logistical challenge:
    *   **Consumption:** All units consume `food`, and all active modules consume `energy`.
    *   **Housing:** The total number of units a player can have is limited by their total `housing` capacity.
    *   **Logistics:** `Courier` units are required for symbolic tasks like installing modules and maintaining storage facilities.
5.  **Expand:** The resources generated by developed buildings are used to train more units (especially `Soldiers`), build more modules, and launch new `Assaults`, thus closing the loop.

## 3. Data Structures

The game state is composed of the following data structures.

### `GameState` (`src/logic/GameState.ts`)
The root object holding the entire state of the game world. It maintains multiple dictionaries for game objects to allow for efficient lookups by different keys.

```typescript
{
    // Building Access
    buildingsById: Dict<string, Building>;
    buildingsByMapId: Dict<number, Building>;

    // Unit Access
    unitsById: Dict<string, Unit>;

    // Player & Faction Access
    players: Dict<string, Player>;
    assaults: Dict<id, Assault>;
}
```

### `Player`
Represents a player in the game.

```typescript
{
    name: string;
    team: number;
    resources: Dict<name, Resource>; // Keyed by resource name
    units: IndependentStat; // Current number of units
    housing: Parameter; // Total housing capacity
    foodConsumption: Parameter; // Total food consumed per second by all units
}
```

### `Resource`
Defines a player's resource, integrating with the reactive Stat system.

```typescript
{
    name: string;
    current: IndependentStat; // Current amount stored
    income: Parameter;        // Net income per tick
    max: Parameter;           // Storage capacity
}
```

### `Building`
A structure on the map that can be controlled and developed.

```typescript
{
    id: string; // Unique game ID
    mapId: number; // Same as map feature ID
    team: number;
    center: Point2;
    boundingRadius: number;
    floors: number;
    floorSize: number;
    slots: Array<BuildingSlot>;
    outputs: Array<GameStat>;
}
```

### `BuildingSlot`
A space within a building that can house a unit or a module.

```typescript
{
    type: BuildingSlotType; // Mask of allowed types
    occupant: number; // Unit ID
    content: number;  // BuildingModule ID
}
```

### `BuildingModule` (Library Definition)
A predefined, installable component that gives a slot functionality.

```typescript
{
    id: string;
    name: string;
    cost: Array<Cost>;
    slotType: BuildingSlotType;
    profession: string;
    produces: Array<{ resource: string, amount: number }>;
    consumes: Array<{ resource: string, amount: number }>;
    storage: Array<{ resource: string, amount: number }>;
    operatorless?: boolean;
}
```

### `Unit`
A character that can be controlled by the player.

```typescript
{
    id: string; // Unique game ID
    pos: Point2;
    team: number;
    occupies: string; // Building ID if garrisoned for defense, else ''
    profession: string;
}
```

#### `Soldier` (Sub-type of Unit)
A specialized unit for combat.

```typescript
{
    // Inherits Unit properties
    profession: 'soldier';
    hp: number;
    maxHp: number;
    armor: number;
    attackAt: number;
    damage: number;
    attackSpeed: number;
    range: number;
}
```

### `Assault`
A data structure representing an ongoing combat scenario at a building.

```typescript
{
    buildingId: number;
    defenders: Array<number>; // Unit IDs
    attackers: Array<number>; // Unit IDs
}
```

### `GameStat` (Building Output)
Represents the aggregated output of a building for a specific resource. It acts as the bridge between static `BuildingModule` definitions and the live `Stat` system.

```typescript
{
    resource: string; // The resource name (e.g., 'food', 'energy')
    income: IndependentStat; // A live stat object representing the building's total output for this resource.
    isStorage: boolean; // If true, this stat affects the resource's max capacity, not its income.
}
```

### Supporting Types

```typescript
// A 2D vector
type Point2 = { x: number, y: number };

// A resource cost for construction/training
type Cost = { resource: string, amount: number };

// Enum for categorizing building slots
enum BuildingSlotType {
    housing = 1,
    production = 2,
    science = 4,
    storage = 8
}
```

## 4. Core Mechanics

### Resource Management
*   **Global Pool:** Player resources (`food`, `energy`, etc.) are stored in a global pool (`Player.resources`).
*   **Symbolic Logistics:** Certain actions require a `Courier` to perform a "delivery". This is a symbolic action that enables the operation. The resources are deducted from the global pool, but the courier's travel time acts as a timer.
    *   **Module Installation:** A courier must bring a "package" to the building site.
    *   **Storage Sorting:** After many transactions, a storage facility must be "sorted" by a courier moving a package to another storage building.
*   **Building Output Calculation:**
    *   When a `BuildingModule` in a building becomes active (installed and occupied), its `income` value is added to the building's corresponding `GameStat.income`. If a `GameStat` for that resource doesn't exist on the building, it is created.
    *   This building-level `GameStat.income` is then connected via an `ADD` connection to the player's global `Resource.income` `Parameter`.
    *   When a module deactivates, its contribution is subtracted, and the connection is updated. This ensures the player's global income always reflects the sum of all active module outputs.
*   **Production Buffers:** Some modules (e.g., `Mines`) produce resources into a local buffer. The output is added to the global pool instantly, but the buffer has a finite size. A courier must empty the buffer periodically, or production will halt.

### Consumption & Penalties
*   **Food:** All units consume food. If the global `food` balance is negative, random units will die. Farmers and soldiers have the lowest priority for dying.
*   **Housing:** It's impossible to hire new units if the player's current number of units (`Player.units`) is equal to or greater than their housing capacity (`Player.housing`). Unlike food or energy, there is no penalty for losing housing while having more units than capacity; the player simply cannot create more units until the situation is resolved.
*   **Energy:** All active `BuildingModules` consume energy. If the global `energy` balance is negative, a random energy-consuming building will be disabled for one minute before attempting to reactivate.

### Unit Management
*   **Housing:** A unit is no longer tied to a specific housing slot. The game only tracks the player's total unit count (`Player.units`) and total housing capacity (`Player.housing`). Housing capacity is increased by building specific modules (e.g., 'shelter-s').
*   **Workplace & Profession:** A unit's profession is determined by the `BuildingModule` it occupies. When assigned to a new job, the unit travels to the building and then begins working. An unassigned unit has the `unemployed` profession.
*   **Garrisoning:** The `Unit.occupies` field is used when a unit (typically a `Soldier`) is garrisoned inside a building for defense. Garrisoned units are not displayed on the map.

### Map & Building Initialization
*   Initial building properties are derived from OSM map data, specifically the `building`, `building:levels`, and `height` properties.
*   Default slot configurations will be applied based on the building type:
    *   `residential`, `house`, `apartments`, `yes`: Primarily `housing` slots.
    *   `industrial`, `commercial`, `retail`: Primarily `production` and `science` slots, with some `storage`.

## 5. Player Input & Actions

Direct player control is managed through a command queue. The simulation is driven by high-level player commands processed each tick.

### Hire Unit
    1.  Checks if the player's current unit count (`player.units.value`) is less than their housing capacity (`player.housing.value`).
    2.  Checks if the player has sufficient resources for the specified `unitType` (e.g., 50 gold for a `worker`).
    3.  If both checks pass, the cost is deducted, a new `Unit` is created.
    4.  The player's `units` stat is incremented, which automatically increases the `foodConsumption` stat it is connected to.

## 6. Core Logic Modules

The game's simulation is primarily handled by a few key modules that are executed during the main game loop (`Model.ts`).

### `InputProcessor` (`src/logic/input/InputProcessor.ts`)
This module is responsible for processing the global command queue. It maps command names to handler functions, ensuring that player inputs are translated into game state changes each tick. It's the entry point for all player-initiated actions like installing modules or hiring units.

### `UnitActions` (`src/logic/UnitActions.ts`)
This module provides high-level actions related to units, such as hiring new units and handling their removal from the game. It encapsulates the logic for checking costs, finding available housing, and updating game state accordingly. Crucially, it also adjusts the player's total food consumption `Stat` whenever a unit is created or destroyed, ensuring the economic simulation is always in sync.

### `Buildings` (`src/logic/Buildings.ts`)
This module contains functions for managing buildings in the game state. It handles creation, module installation, and unit assignment, including the logic for applying and reversing resource effects from building modules. It also contains helpers for checking a building's state, such as its resource consumption or whether it is currently disabled due to an energy shortage.

### `Economy` (`src/logic/Economy.ts`)
This module manages the game's economic simulation. It runs every tick to update player resources based on their net income. It also handles periodic checks for resource deficits. If a player's `energy` balance is negative, it will randomly shut down an energy-consuming building for a short period. If the `food` balance is negative, it will trigger a "starvation" event, where units will begin to die off until the food balance is restored.

## 7. Open Questions
*   Definition of "items" and how they are equipped by units.
*   Detailed formulas for combat resolution within an `Assault`.
*   Specific mechanics for `Courier` automation vs. manual control.